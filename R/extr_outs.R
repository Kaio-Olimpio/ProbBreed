## Function extr_outs
##
##' This function extracts outputs of the Bayesian model fitted using "rstan",
##' and provides some diagnostics about the model
##'
##' @title Extracting outputs of "rstan" models
##' @param data A dataframe containing the observations
##' @param trait A character representing the name of the column that
##' corresponds to the analysed variable
##' @param gen A character representing the name of the column that
##' corresponds to the evaluated genotypes
##' @param model An object containing the Bayesian model fitted using rstan
##' @param effects A string vector containing the codes of the effects included
##' in the model. The codes are:
##' \itemize{
##' \item \code{r} : replicate effect
##' \item \code{b} : block inside replicate effect (if the trials are lattices)
##' \item \code{l} : environment (or location) effect
##' \item \code{m} : region effect (if it is available)
##' \item \code{g} : genetic effect
##' \item \code{gl} : genotype-by-location effect
##' \item \code{gm} : genotype-by-region effect
##' }
##' @param nenv The number of environments in the analysis
##' @param res.het Are the residual heterogeneous? Default is FALSE
##' @param check.stan.diag A logical value indicating whether the function should
##' extract some diagnostic using native stan functions.
##' @param ... Passed to stan_diag (for more information, see stan_diag manual)
##' @return The function returns a list with:
##' \itemize{
##' \item \code{post} : a list with the posterior of the effects, and the data
##' generated by the model
##' \item \code{variances} : a dataframe with the variances of each effect
##' \item \code{map} : a list with the maximum posterior values of each effect
##' \item \code{ppcheck} : a matrix containing the p-values of maximum, minimum,
##' median, mean and standard deviation; effective number of parameters, WAIC2
##' value and Rhat
##' \item \code{den_plot} a density plot comparing the generated data and the
##' real data. Note that this plot is customizable using the "ggplot2" library
##' }
##'
##'
##' @export
##'
##' @import rstan ggplot2
##' @importFrom utils write.csv
##'
##'
##'
##' @examples
##' \dontrun{outs = extr_outs(data = df, trait = "GY", gen = "H", model = Model4,
##'                  effects = c("r", "b", "l", "m", "g", "gl", "gm"),
##'                  nenv = 16, res.het = TRUE, check.stan.diag = TRUE)}

extr_outs = function(data, trait, gen, model, effects, nenv, res.het = FALSE,
                     check.stan.diag = FALSE, ...){

  requireNamespace('ggplot2')
  requireNamespace('rstan')

  # Data
  data = data

  # Extract stan results
  out <- rstan::extract(model, permuted = TRUE)

  # Posterior effects
  post = list()
  for (i in effects) {
    post[[i]] = out[[i]]
  }
  rm(i)

  # Variances
  if(res.het == F){

    variances = NULL
    for (i in c(effects,'sigma')) {
      all_variances = out[[paste("s",i,sep='_')]]^2
      variances[i] = mean(all_variances)
    }
    variances = data.frame(
      effect = c(effects,'res'),
      var = variances,
      row.names = NULL
    )

    rm(all_variances)
    rm(i)

  } else {

    variances = NULL
    for (i in c(effects)) {
      all_variances = out[[paste("s",i,sep='_')]]^2
      variances[i] = mean(all_variances)
    }

    variances = data.frame(
      effect = c(effects, paste0('res.env_', 1:nenv)),
      var = c(variances, apply(out[['sigma']]^2, 2, mean)),
      row.names = NULL
    )

    rm(all_variances)
    rm(i)
  }

  # Maximum posterior values (MAP)
  get_map <- function(posterior) {
    posterior <- as.matrix(posterior)
    if (ncol(posterior) > 1) {
      den = apply(posterior, 2, density)
      map = unlist(lapply(den, function(den)
        den$x[which.max(den$y)]))
    }
    else {
      den = density(posterior)
      map = den$x[which.max(den$y)]
    }
    return(map)
  }
  map = lapply(post, get_map)

  # Data generated by the model
  post[['y_gen_post']] <- out[['y_gen']]

  # Diagnostics
  ns = length(out$mu)
  y = data[,trait]
  N = length(y)
  temp = apply(out$y_gen, 1, function(x) {
    c(
      max = max(x) > max(y),
      min = min(x) > min(y),
      median = quantile(x, 0.5) > quantile(y, 0.5),
      mean = mean(x) > mean(y),
      sd = sd(x) > sd(y)
    )
  })
  p_value_max = sum(temp["max",]) / ns
  p_value_min = sum(temp["min",]) / ns
  p_value_median = sum(temp["median.50%",]) / ns
  p_value_mean = sum(temp["mean",]) / ns
  p_value_sd = sum(temp["sd",]) / ns

  temp_v = apply(out$y_log_like, 2, function(x) {
    c(val = log((1 / ns) * sum(exp(x))),
      var = var(x))
  })
  lppd = sum(temp_v["val", ])
  p_WAIC2 = sum(temp_v["var", ]) # Effective number of parameters
  elppd_WAIC2 = lppd - p_WAIC2
  WAIC2 = -2 * elppd_WAIC2
  output_p_check = round(t(
    cbind(
      p_value_max = p_value_max,
      p_value_min = p_value_min,
      p_value_median = p_value_median,
      p_value_mean = p_value_mean,
      p_value_sd = p_value_sd,
      Eff_Npar = p_WAIC2,
      WAIC2 = WAIC2,
      Rhat = mean(summary(model)$summar[,"Rhat"]),
      n_eff = mean(summary(model)$summar[,"n_eff"])/4000
    )
  ), 4)
  colnames(output_p_check) <-
    "Diagnostics"

  plot = data.frame(
    y = c(y, c(out[['y_gen']])),
    type = c(rep('Real data', length(y)), rep('Generated data', length(c(out[['y_gen']]))))
  )
  den_plot = ggplot(plot) +
    geom_density(aes(x = y, color = type, fill = type), alpha = .4) +
    scale_color_manual(values = c("#0E74E7", "#D65B00"))+
    scale_fill_manual(values = c("#0E74E7", "#D65B00"))+
    theme(legend.position = 'bottom')+
    labs(fill="",color="", y = 'Density', x = 'Adjusted mean')


  if(check.stan.diag){
    stan.plot.list = list(
      diag = stan_diag(model, ...),
      rhat = stan_rhat(model),
      ess = stan_ess(model),
      mcse = stan_mcse(model)
    )
    results = list(post, variances, map, output_p_check, den_plot, stan.plot.list)
    names(results) = c('post', 'variances', 'map', 'ppcheck', 'den_plot', 'stan_plots')
  }else{
    results = list(post, variances, map, output_p_check, den_plot)
    names(results) = c('post', 'variances', 'map', 'ppcheck', 'den_plot')
  }

  return(results)
}

